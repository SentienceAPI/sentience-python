name: Sync Extension from sentience-chrome

on:
  repository_dispatch:
    types: [extension-updated]
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag from sentience-chrome (e.g., v1.0.0)'
        required: true
        type: string
  schedule:
    # Check for new releases daily at 2 AM UTC
    - cron: '0 2 * * *'

jobs:
  sync-extension:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      
    steps:
    - name: Checkout sdk-python
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0  # Fetch all history for proper branching
        
    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.11'
        
    - name: Determine release tag
      id: release
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          TAG="${{ github.event.inputs.release_tag }}"
        elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
          TAG="${{ github.event.client_payload.release_tag }}"
        else
          # Scheduled check - get latest release
          TAG=$(curl -s https://api.github.com/repos/${{ secrets.SENTIENCE_CHROME_REPO }}/releases/latest | jq -r '.tag_name // empty')
        fi
        
        if [ -z "$TAG" ] || [ "$TAG" == "null" ]; then
          echo "No release found, skipping"
          echo "skip=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Release tag: $TAG"
        
    - name: Download extension files
      if: steps.release.outputs.skip != 'true'
      run: |
        TAG="${{ steps.release.outputs.tag }}"
        REPO="${{ secrets.SENTIENCE_CHROME_REPO }}"

        # Download extension-files.tar.gz from release
        mkdir -p extension-temp
        cd extension-temp

        echo "üìÅ Downloading extension-files.tar.gz from release..."
        echo "üîç DEBUG: REPO=$REPO, TAG=$TAG"

        # Debug: Check if we can access the release at all
        echo "üîç DEBUG: Testing API access to release..."
        RELEASE_INFO=$(curl -s -H "Authorization: token ${{ secrets.SENTIENCE_CHROME_TOKEN }}" \
          "https://api.github.com/repos/$REPO/releases/tags/$TAG")

        echo "üîç DEBUG: Raw API response:"
        echo "$RELEASE_INFO"
        echo ""
        echo "Release info:"
        echo "$RELEASE_INFO" | jq -r '.name, .tag_name' || echo "Failed to parse release info"

        # Check for error message
        ERROR_MSG=$(echo "$RELEASE_INFO" | jq -r '.message // empty')
        if [ -n "$ERROR_MSG" ]; then
          echo "‚ùå API Error: $ERROR_MSG"
          echo "This usually means the token doesn't have access to the Organization repo"
        fi

        # For private repos, use the API URL with asset ID, not browser_download_url
        ASSET_INFO=$(echo "$RELEASE_INFO" | \
          jq -r '.assets[] | select(.name=="extension-files.tar.gz") | "\(.id)|\(.url)"')

        if [ -z "$ASSET_INFO" ] || [ "$ASSET_INFO" == "null" ]; then
          echo "‚ùå extension-files.tar.gz not found in release assets"
          echo "Available assets:"
          echo "$RELEASE_INFO" | jq -r '.assets[] | "\(.name) (id: \(.id))"'
          echo ""
          echo "Full release response (first 500 chars):"
          echo "$RELEASE_INFO" | head -c 500
          exit 1
        fi

        ASSET_ID=$(echo "$ASSET_INFO" | cut -d'|' -f1)
        ASSET_URL=$(echo "$ASSET_INFO" | cut -d'|' -f2)

        echo "  Asset ID: $ASSET_ID"
        echo "  Downloading from API: $ASSET_URL"

        # Download using the API URL with Accept header (required for private repos)
        curl -L \
          -H "Authorization: token ${{ secrets.SENTIENCE_CHROME_TOKEN }}" \
          -H "Accept: application/octet-stream" \
          "$ASSET_URL" -o extension-files.tar.gz

        # Verify download
        if [ ! -f "extension-files.tar.gz" ]; then
          echo "‚ùå Failed to download extension-files.tar.gz"
          exit 1
        fi

        TARBALL_SIZE=$(wc -c < extension-files.tar.gz)
        echo "‚úÖ Downloaded extension-files.tar.gz ($TARBALL_SIZE bytes)"

        # Extract tar.gz (preserves directory structure)
        echo "üì¶ Extracting extension-files.tar.gz..."
        tar -xzf extension-files.tar.gz
        rm extension-files.tar.gz

        # Verify extracted files
        echo "üìã Extracted files structure:"
        find . -type f | sort
        echo ""
        echo "üîç Verifying critical files:"
        if [ -f "manifest.json" ]; then
          size=$(wc -c < manifest.json)
          echo "‚úÖ manifest.json found ($size bytes)"
          if [ "$size" -lt 100 ]; then
            echo "‚ö†Ô∏è  manifest.json seems too small, showing content:"
            cat manifest.json
            exit 1
          fi
          head -5 manifest.json
        else
          echo "‚ùå manifest.json NOT FOUND"
          exit 1
        fi
        if [ -d "pkg" ]; then
          echo "‚úÖ pkg directory found with $(ls -1 pkg | wc -l) files"
          ls -lh pkg/
        else
          echo "‚ùå pkg directory NOT FOUND"
          exit 1
        fi
        
    - name: Copy extension files
      if: steps.release.outputs.skip != 'true'
      run: |
        # Create extension directory structure
        mkdir -p sentience/extension/pkg
        
        # Copy extension files (handle both root and extension-package/ subdirectory)
        # Check root first, then extension-package/ subdirectory
        if [ -f "extension-temp/manifest.json" ]; then
          size=$(wc -c < extension-temp/manifest.json)
          if [ "$size" -gt 0 ]; then
            echo "‚úÖ Copying manifest.json ($size bytes)"
            cp extension-temp/manifest.json sentience/extension/
            # Verify copy
            if [ -f "sentience/extension/manifest.json" ] && [ "$(wc -c < sentience/extension/manifest.json)" -gt 0 ]; then
              echo "‚úÖ manifest.json copied successfully"
            else
              echo "‚ùå manifest.json copy failed or file is empty"
              exit 1
            fi
          else
            echo "‚ùå manifest.json is empty ($size bytes)"
            exit 1
          fi
        elif [ -f "extension-temp/extension-package/manifest.json" ]; then
          size=$(wc -c < extension-temp/extension-package/manifest.json)
          if [ "$size" -gt 0 ]; then
            echo "‚úÖ Copying manifest.json from extension-package/ ($size bytes)"
            cp extension-temp/extension-package/manifest.json sentience/extension/
            # Verify copy
            if [ -f "sentience/extension/manifest.json" ] && [ "$(wc -c < sentience/extension/manifest.json)" -gt 0 ]; then
              echo "‚úÖ manifest.json copied successfully"
            else
              echo "‚ùå manifest.json copy failed or file is empty"
              exit 1
            fi
          else
            echo "‚ùå manifest.json is empty ($size bytes)"
            exit 1
          fi
        else
          echo "‚ùå manifest.json not found in extension-temp/"
          echo "Available files:"
          find extension-temp -type f | head -20
          exit 1
        fi
        
        if [ -f "extension-temp/content.js" ]; then
          cp extension-temp/content.js sentience/extension/
        elif [ -f "extension-temp/extension-package/content.js" ]; then
          cp extension-temp/extension-package/content.js sentience/extension/
        else
          echo "‚ö†Ô∏è content.js not found"
        fi
        
        if [ -f "extension-temp/background.js" ]; then
          cp extension-temp/background.js sentience/extension/
        elif [ -f "extension-temp/extension-package/background.js" ]; then
          cp extension-temp/extension-package/background.js sentience/extension/
        else
          echo "‚ö†Ô∏è background.js not found"
        fi
        
        if [ -f "extension-temp/injected_api.js" ]; then
          cp extension-temp/injected_api.js sentience/extension/
        elif [ -f "extension-temp/extension-package/injected_api.js" ]; then
          cp extension-temp/extension-package/injected_api.js sentience/extension/
        else
          echo "‚ö†Ô∏è injected_api.js not found"
        fi
        
        # Copy WASM files - try multiple locations and patterns
        echo "üîç Searching for pkg directory and WASM files..."
        
        # Check all possible locations
        if [ -d "extension-temp/pkg" ]; then
          echo "‚úÖ Found pkg directory at extension-temp/pkg"
          cp -r extension-temp/pkg/* sentience/extension/pkg/ 2>/dev/null || true
        elif [ -d "extension-temp/extension-package/pkg" ]; then
          echo "‚úÖ Found pkg directory at extension-temp/extension-package/pkg"
          cp -r extension-temp/extension-package/pkg/* sentience/extension/pkg/ 2>/dev/null || true
        else
          echo "‚ö†Ô∏è pkg directory not found, searching for individual files..."
          
          # Search for files in various locations
          find extension-temp -name "sentience_core.js" -type f | while read file; do
            echo "  Found: $file"
            cp "$file" sentience/extension/pkg/ 2>/dev/null || true
          done
          
          find extension-temp -name "sentience_core_bg.wasm" -type f | while read file; do
            echo "  Found: $file"
            cp "$file" sentience/extension/pkg/ 2>/dev/null || true
          done
          
          find extension-temp -name "*.d.ts" -type f | while read file; do
            echo "  Found: $file"
            cp "$file" sentience/extension/pkg/ 2>/dev/null || true
          done
        fi
        
        # Verify copied files
        echo "üìã Copied files:"
        echo "Extension root:"
        ls -la sentience/extension/ || echo "‚ö†Ô∏è Extension directory empty"
        echo ""
        echo "WASM files (pkg directory):"
        if [ -d "sentience/extension/pkg" ]; then
          ls -la sentience/extension/pkg/ || echo "‚ö†Ô∏è pkg directory empty"
        else
          echo "‚ùå ERROR: pkg directory not created!"
          exit 1
        fi
        
        # Verify required files exist
        if [ ! -f "sentience/extension/pkg/sentience_core.js" ]; then
          echo "‚ùå ERROR: sentience_core.js not found!"
          exit 1
        fi
        if [ ! -f "sentience/extension/pkg/sentience_core_bg.wasm" ]; then
          echo "‚ùå ERROR: sentience_core_bg.wasm not found!"
          exit 1
        fi
        echo "‚úÖ All required WASM files verified"
        
        # Clean up temporary directory
        cd ..
        rm -rf extension-temp
        echo "üßπ Cleaned up extension-temp directory"
        
    - name: Check for changes
      if: steps.release.outputs.skip != 'true'
      id: changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Show what files exist before adding
        echo "üìã Files in sentience/extension before git add:"
        find sentience/extension -type f | sort || echo "No files found"
        
        # Add all files including binary files
        # Use -f to force add in case files are in .gitignore
        git add -f sentience/extension/ || true
        
        # Show what was staged
        echo "üìã Staged files:"
        git diff --staged --name-only || echo "No staged files"
        
        # Check if there are actual changes
        if git diff --staged --quiet; then
          echo "changed=false" >> $GITHUB_OUTPUT
          echo "No changes detected"
        else
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "Changes detected"
          # Show file sizes to verify binary files are included
          echo "üìä Staged file sizes:"
          git diff --staged --name-only | while read file; do
            if [ -f "$file" ]; then
              size=$(ls -lh "$file" | awk '{print $5}')
              echo "  $file: $size"
            fi
          done
        fi
        
    - name: Create Pull Request
      if: steps.release.outputs.skip != 'true' && steps.changes.outputs.changed == 'true'
      uses: peter-evans/create-pull-request@v5
      with:
        # Use PR_TOKEN if available (for repos with org restrictions), otherwise use GITHUB_TOKEN
        # To use PAT: create secret named PR_TOKEN with a Personal Access Token that has 'repo' scope
        token: ${{ secrets.PR_TOKEN }}
        commit-message: "chore: sync extension files from sentience-chrome ${{ steps.release.outputs.tag }}"
        title: "Sync Extension: ${{ steps.release.outputs.tag }}"
        body: |
          This PR syncs extension files from sentience-chrome release ${{ steps.release.outputs.tag }}.
          
          **Files updated:**
          - Extension manifest and scripts
          - WASM binary and bindings
          
          **Source:** [sentience-chrome release ${{ steps.release.outputs.tag }}](https://github.com/${{ secrets.SENTIENCE_CHROME_REPO }}/releases/tag/${{ steps.release.outputs.tag }})
        branch: sync-extension-${{ steps.release.outputs.tag }}
        delete-branch: true
        labels: |
          automated
          extension-sync

